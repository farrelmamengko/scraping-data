name: Deploy Scraper Tender App ke NAS

on:
  push:
    branches: [ master ]  # Sesuaikan dengan branch Anda
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2
    
    - name: Login to DockerHub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v4
      with:
        context: .
        push: true
        tags: ${{ secrets.DOCKERHUB_USERNAME }}/scraper-tender-app:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max
    
    - name: Install SSH client and sshpass
      run: |
        sudo apt-get update
        sudo apt-get install -y openssh-client sshpass netcat-openbsd
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        ssh-keyscan -p ${{ secrets.NAS_PORT }} ${{ secrets.NAS_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true
        chmod 600 ~/.ssh/known_hosts
    
    - name: Debug SSH Connection
      env:
        SSHPASS: ${{ secrets.NAS_PASSWORD }}
      continue-on-error: true
      run: |
        echo "Memeriksa koneksi SSH ke NAS..."
        echo "Host: ${{ secrets.NAS_HOST }}"
        echo "Port: ${{ secrets.NAS_PORT }}"
        echo "Username: ${{ secrets.NAS_USERNAME }}"
        
        # Cek koneksi dengan timeout yang lebih pendek
        export SSHPASS="$SSHPASS"
        timeout 10 sshpass -e ssh -v -o StrictHostKeyChecking=no -o ConnectTimeout=5 -p ${{ secrets.NAS_PORT }} ${{ secrets.NAS_USERNAME }}@${{ secrets.NAS_HOST }} 'echo "Test koneksi SSH"' || echo "Koneksi SSH gagal dengan status $?"
        
        # Cek apakah port SSH terbuka
        echo "Memeriksa apakah port SSH terbuka..."
        nc -z ${{ secrets.NAS_HOST }} ${{ secrets.NAS_PORT }} -w 10 || echo "Pemeriksaan port gagal dengan status $?"
    
    - name: Deploy to NAS
      env:
        SSHPASS: ${{ secrets.NAS_PASSWORD }}
        DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
        DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        APP_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/scraper-tender-app:latest
      run: |
        export SSHPASS="$SSHPASS"
        
        # Coba koneksi SSH sederhana
        echo "Mencoba koneksi SSH..."
        sshpass -e ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p ${{ secrets.NAS_PORT }} ${{ secrets.NAS_USERNAME }}@${{ secrets.NAS_HOST }} 'echo "Koneksi SSH berhasil"'
        
        # Jalankan perintah deployment langsung melalui SSH
        echo "Menjalankan perintah deployment melalui SSH..."
        sshpass -e ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p ${{ secrets.NAS_PORT }} ${{ secrets.NAS_USERNAME }}@${{ secrets.NAS_HOST }} "
          # Buat direktori jika belum ada
          mkdir -p /volume1/docker/skk-tender-staging
          cd /volume1/docker/skk-tender-staging
          
          # Buat direktori data jika belum ada
          mkdir -p data
          
          # Set default Docker command
          docker_cmd='docker'
          
          # Check if default path exists, if not try alternatives
          if ! command -v \$docker_cmd &> /dev/null; then
            for cmd in '/usr/local/bin/docker' '/volume1/@appstore/Docker/usr/bin/docker' '/usr/bin/docker'; do
              if [ -x \"\$cmd\" ]; then
                docker_cmd=\"\$cmd\"
                echo \"Found Docker at \$docker_cmd\"
                break
              fi
            done
          fi
          
          # Verify Docker was found
          if ! command -v \$docker_cmd &> /dev/null; then
            echo \"Docker not found in any expected location\"
            exit 1
          fi
          
          # Check if docker-compose exists
          compose_cmd='docker compose'
          
          # if docker compose plugin is not available, look for docker-compose binary
          if ! \$docker_cmd compose version &> /dev/null; then
            for cmd in '/usr/local/bin/docker-compose' '/volume1/@appstore/Docker/usr/bin/docker-compose' '/usr/bin/docker-compose'; do
              if [ -x \"\$cmd\" ]; then
                compose_cmd=\"\$cmd\"
                echo \"Found Docker Compose at \$compose_cmd\"
                break
              fi
            done
          fi
          
          # Login ke DockerHub
          echo \"${DOCKERHUB_TOKEN}\" | \$docker_cmd login -u \"${DOCKERHUB_USERNAME}\" --password-stdin
          
          # Buat atau perbarui docker-compose.yml
          cat > docker-compose.yml << 'EOF'
          version: '3.8'
          services:
            app:
              container_name: scraper_tender_app
              image: IMAGE_PLACEHOLDER
              ports:
                - \"3002:3000\"
              restart: unless-stopped
              volumes:
                - ./data:/app/data
          EOF
          
          # Ganti variabel di docker-compose.yml
          sed -i \"s|IMAGE_PLACEHOLDER|${APP_IMAGE}|g\" docker-compose.yml
          
          echo \"File docker-compose.yml dibuat\"
          
          # Pull image terbaru
          \$docker_cmd pull ${APP_IMAGE}
          
          # Restart containers menggunakan docker-compose atau docker compose
          if [[ \$compose_cmd == *'docker-compose'* ]] || \$docker_cmd compose version &> /dev/null; then
            echo \"Menggunakan \$compose_cmd untuk deployment...\"
            \$compose_cmd down 2>/dev/null || true
            \$compose_cmd up -d
          else
            # Fallback ke docker run jika docker-compose tidak tersedia
            echo \"Docker Compose tidak ditemukan, menggunakan Docker run...\"
            
            # Stop dan hapus container yang sudah ada
            \$docker_cmd stop scraper_tender_app 2>/dev/null || true
            \$docker_cmd rm scraper_tender_app 2>/dev/null || true
            
            # Jalankan aplikasi
            \$docker_cmd run -d \\
              --name scraper_tender_app \\
              --restart unless-stopped \\
              -p 3002:3000 \\
              -v \"\$(pwd)/data:/app/data\" \\
              ${APP_IMAGE}
          fi
          
          # Bersihkan image yang tidak digunakan
          \$docker_cmd image prune -f
          
          echo \"Deployment berhasil\"
          echo \"Aplikasi seharusnya tersedia di http://\$(hostname -I | awk '{print \$1}'):3002\"
        " 